ve Monday. originnﬂ worked fur Hewson in I984, where he produted Y. nk an Tad. Ha fhan movud m N, when: 
M pmdutad cum Cup." m mid was my Slick-r mm. nexv m I986 fov Hawscn. In auﬂy1987 Slave moved lo Gremlin Graphics and pmduced 
Final mm, m \997 Christmas compendium, Apm was saw me mm cl Blood 5mm." for Gmmlln. More mamly, 5m. ﬁnvshad 4x4 ou-noua Iatlng (or us Go‘d. 
Dunng main-1r yuan o6 pmgmmmmg, snm has worked with Dave Cache, Bohr: he sums programming, he mad: sum. (has 5m: Morsden u u p>|ol

DOES SPRITE DETECTION WORK? 
<p>In a program such as u gama oru uViMy wilh o moving poinlav arm" by o mouse/Wudm' ball, ﬁver: wrll be rorrr. form of daemon lemme llllro movlng gloom imamcl in some way. If m: dolmon rouhne >5 o good una, men th: results on Oh: 5cm" wlll o. leuaHy more plenxlng. way. all ployoa games where you are croan (ally 'rying lo move your mum charuc‘el away from o hosMe one", only Vu be killed 066 by anmher whldl looks to o: a 990d Mu Inches from Ike main chamdu. 

<p>It can be exlramuly drlﬁrull lo come up wilfl an olgorrllrrrr whlth doesn't hike: up hours ol zxacmiorl llrrre and sllll leave an orreplablo :olhslan demo non lyslerrr Al the and ol llr. day Merefova rl rr all down lo how muchAorhWhMe—llme llre pmgmmmer (an allow lor mo datum" rolmne AI llro and cl m amda, l have Mal. lor. o small lemma whkh g as no ullmme m daemon — p.on devedlon. * your compmer loochm always say _ "A (our pmu (an do onyVhlng yell pvogmm rl lo aow nrrr rr also m. (use when deslgnlng do. lemorr valmnes Mox' pragv rammnrs go «or llro Em melhod l will descnbe 7 Box damdion

<p>Vrmrolly uvory 3pm: rho. has ever bun drawn, slam out Ha 
as a racmgulur array of by» m. army cl by": is man iranxiama ima a superdoap a spamrah or am, gmphi: will. a sunahle adiﬁng package and llla ramming dala is called a sprila lrama, la move this :prifu around vile serean. ill. animavian romine will ply a ml the maaguluv army la “1' msposilianxanlhoscmu map. New unless we dmw n remngulur box shape which perfeniy lim up wlh m. adges al llla army al hm: making up llia ipriVB, "Ian iii. odd (cl-liar al ma army w." consist al fresh air or "am? "as: ,ll 

<p>Nowmi, w: don'l uduully sat up a malangular army at say 10 characters by 10 charanus in size and only dmw a 2 x 2 chowder shu A Mar-over m salsa a W. In x .almaanlammalw. more av [95: 5| ﬂi- mangle wilh only a law bum (emu: shwwing. This factor allows us In use a maihamalical lam. ai dame" known m box datum Non. 

<p>Namally, a sail. will have a few In! nun? variable: assoclmad Will. .l These are a. ll». vary stian x corordinuﬁa, v co-ordlnava and possibly venubles Iall'lng us how wide the same is and also how dgsp w is, Now ii is quile an easy muﬂav 1mm HI lnlamﬁon uboul a sprite la deiomlina wliallm an overlap has occur» red beMean Mo 5 rite recDouglas M». u w. a ememury mam;

<p>if all law spnles were boxas a, remnglas, than um mulhod would b. inlallibl. The rm». .5, huwaver, Ma! am smiles have (Oman missing as in no, 'I. Supposa Mo xpmax am overlapping by lheir (amen, lhe ruuﬁno above w.ll sense «law may are even lapping . [M on he screen we would mal see an overlap in llle pion meeting pxel some, lo be, ll would mm mm me Me 1p"!!! were milos upon bul they sh’ll a. and each allier wlial is required mm. is a lamina which actually dammines pixel In pixel coll‘lsionx

<p>me Hawmn gama <b>Technician Ted</b> usad pixal daiacllam and m d lpoxsible la .ae llla foam. xlansivolyln lls game play. ‘lho mam character could limrally walk up la a hosﬁle spnla unvil his nose was only one pixel away from aeaib, This sound: qune a tampll» cm aloalomiliemiiaee,binin no "1 il a so easy e m. logxol lnswdlnn ’AND' dam ll all for you 

<p>Just mmk abmn ii a. ma Inwasl lwnl, A sprlle is data and ill. moon is ulm data — iusl numbers la diaw a spma am a ma." molly moam moi we om mking one byio aldala from one place and mixing ii ilh analliei byle of dam in anonher plaee and man storing ma mow dulu byte in ma xcreen memory Ramambor ma mnh iable lat mo logical AND inslmcilon: 
    
A a C o 0 0 o 1 D l 0 o l 1 I 

<p>Column A is one bio al dam while column B is another bil of aala. If we assume ma. a pixel lsu'l'oru selbilin a bytelhen an ovorlop in logic lerms means he can when A : B : 'l Yhe column C in Wm case produces a '1' when ball. A and B are ’J '. 

<p>ll»; shows dearly liaw we can me he AND to cleats a 'on ammo" syslam me axampla piagiam belaw was an AND lnslnlction in )hg delecr 'lGVI rouﬁna but 10 does seem to ba buried under a lol ac other inxlmcllons r l IS because a few other consularalions have somatvmas la be appliea such m ompmﬁn mg 5pm: la m. Kroc" For . morn mwuL I, minded m.» mm, I havugd on ma mu. 0' mnpm mmine which combine: the pixal dolnc'ion us we”, 

<p>A wer deiacnan mum am no! 9N. any char invarmuﬁnn upar‘ from mung Us ma» an ovadop hos ocwrved For .xumpla, a collision Hugh! occur between m spnlas and a background mm. such as a wall. rha sprita «a who comm m m b. acumable — u Mandly c mum pm”; 7 buy m. paw deledion :4:an diﬁerermo‘a hem." .mls. A .ml :nuld balcng 90 n we”, a frog, a pawl! pm, bu! m. mvﬁ doasnotkuow where n ongnmd 5mm, m is why pixel anemia" (an grow u. very complimhd lawn; and as m». it as why pvogmmmaﬁ usually sh, W Mm n, 

<p>meuvabiy rypu 2.. m murce coda into an assembler and pmduce me pmgrum ohm way. For mm who haven’t got an ummbltr (lam yourself a slavpcd was“), type m m mic rmgmm and .an m. 
dmm numben «a... me ImIng supplmd.
<pre>
10 FOR N=32768 TO 33159
20 INPUT (N);"-";A
30 POKE N,A
40 PRINT N;" ";A
50 NEXT N 
</pre>
To run m. pvogmm, do u <tt>RANDOMIZE USR 32768</tt> and 
in! watch whuv happens , hopeluﬂy a ﬂurry baKkgraund wnh a squcr: shapes moving many"! a. 19 "mm «1 BASIC prus m. SPACE bur. Poke mg uddmses 32792 and 32324 with any number 6mm I m a m dam.“ how many of m. square shape: you wum.

<p>Once m. program has hm emamd, 90 Save the machine (0d: my. in <tt>SAVE "detect" CODE 32768,391</tt>

<pre>
                                 ORG 08000H
NO_SHAPES:                       EQU 6
DETECT_DEMO:
        LD A,1                   ; set the border to blue
        OUT (£FE),A
        LD HL,£4000              ; clear the pixel screen
        LD DE,£4001
        LD BC,£17FF
        LD (HL),L
        LDIR
        CALL DRAW_STARS          ; draw in the background and borders
        LD IX,BLOB_VARS          ; set up IX to point to the first set
        LD B,NO_BLOBS            ; of shape variables and make B equal
                                 ; to the number of shapes we want
INIT_LOOP:
        PUSH BC                  ; preserve B - the counter
        LD D,(IX+1)              ; set up DE with the X and Y coords
        LD E,(IX+0)              ; of the shape
        CALL DRAW_BLOB           ; draw it to the screen
        LD C,4
        ADD IX,BC                ; make IX point to the next shape
        POP BC                   ; restore B
        DJNZ INIT_LOOP           ; loop back to draw in the rest of
                                 ; the shapes
MAIN_LOOP:                       ; synchronise the output loop with a
        LD BC,1900               ; HALT and set up BC for the flicker
DELAY:  DEC BC                   ; reducing counter
        BIT 7,B                  ; if BC has not gone negative then go
        JR Z,DELAY               ; back (1901 times)
        LD IX,BLOB_VARS          ; initialise IX to the shape variable
        LD B,NO_BLOBS            ; list and B as a counter to the
BLOB_LOOP:                       ; number of shapes required
        PUSH BC                  ; save the counter
        CALL OUTPUT_BLOB         ; CALL the main shape output and test
                                 ; routine
        CALL NC,CHANGE_DIR       ; NO CARRY from OUTPUT_BLOB
                                 ; means that collision has occurred so we
                                 ; CALL CHANGE_DIR to make the shape
        LD BC,4                  ; rebound
        ADD IX,BC                ; move IX on to the next set of shape
        POP BC                   ; variables and restore B
        DJNZ BLOB_LOOP           ; loop back as required
        LD A,£7F                 ; set A to the keyboard half row
        IN A,(£FE)               ; B-SPACE and read it
        RRA                      ; check Bit 0 (SPACE)
        JR C,MAIN_LOOP           ; jump back if not pressed
        RET                      ; else return to BASIC
CHANGE_DIR:
        CALL DIR10               ; CALL DIR10 to get a random value of
        LD (IX+2),A              ; 0,1,-1 into the accumulator. Store
        LD C,A                   ; it in the X movement variable
                                 ; (IX+2) and also temporarily in C
        CALL DIR10               ; do the same for the Y movement
        OR C                     ; variable and then OR it with C
                                 ; if the X and Y movement variables
        JR Z,CHANGE_DIR          ; are both zero then the shape would
                                 ; not move so jump back to CHANGE_DIR
        RET                      ; then return
DIR10:  CALL RAND_NUM            ; get an 8-bit random number
        CP 96
        JR NC,DIR20              ; jump if A>96
        LD A,-1                  ; if A is 0-95, then make A=-1
        RET
DIR20:  CP 160
        JR C,DIR30               ; jump if A<160
        LD A,1                   ; if A>160 then make A=1
        RET
DIR30:  XOR A                    ; if 96<=A<160 then make A=0
        RET
DRAW_STARS:
        LD BC,£FFBF              ; make BC = counter values
        LD DE,0                  ; DE = screen top left coordinates
ST10:   CALL PLOT                ; plot at DE
        INC E                    ; stEp along a pixel
        DJNZ ST10                ; and repeat for 255 times
        LD B,C                   ; make B = 191
ST20:   CALL PLOT                ; plot at top right corner
        INC D                    ; and step down the screen 191 times
        DJNZ ST20
        DEC B                    ; decrement B to make it = 255
ST30:   CALL PLOT                ; plot at bottom right corner
        DEC D                    ; step from right to left
        DJNZ ST30                ; for 255 times
        LD B,C                   ; make B = 191
ST40:   CALL PLOT                ; plot at bottom left corner
        DEC D                    ; and step up the left edge of the
        DJNZ ST40                ; screen for 191 times
        INC B                    ; make BC = 447
ST50:   PUSH BC                  ; save it
        CALL Y_RAND_NUM          ; get random number from 0-191
        LD D,A                   ; put it in D
        CALL RAND_NUM            ; now get one from 0-255
        LD E,A                   ; and put it in E
        CALL PLOT_ADDR           ; now plot at this random coordinate
        OR (HL)                  ; by OR'ing with the screen
        LD (HL),A                ; pointed at by HL
        POP BC                   ; restore the counter
        DEC BC                   ; decrement it and loop back for 448
        BIT 7,B                  ; times (until BC goes negative)
        JR Z,ST50
        RET
OUTPUT_BLOB:
        LD D,(IX+1)              ; set up DE from the shape coordinate
        LD E,(IX+0)              ; variables
        CALL DRAW_BLOB           ; rub out the blob from its present
                                 ; position
        LD A,(IX+2)              ; now add in the X movement variable
        ADD A,E                  ; to the X coordinate and put in E
        LD E,A
        LD A,(IX+3)              ; do the same with the Y movement
        ADD A,D                  ; variable but put it in D
        LD D,A
        CALL DRAW_BLOB           ; draw in the shape at the new moved
                                 ; position
        JR C,PUT_BACK            ; if there was a CARRY, then the new
                                 ; position has hit a pixel so jump
                                 ; to PUT_BACK and don't move
        LD (IX+1),D              ; if the new position was OK then
        LD (IX+0),E              ; store the new X and Y coordinates
        SCF                      ; and set the CARRY before returning
        RET                      ; to signal - MOVE SUCCESSFUL
PUT_BACK:
        CALL DRAW_BLOB           ; rub out the moved shape
        LD D,(IX+1)
        LD E,(IX+0)              ; Y position
        CALL DRAW_BLOB           ; and re-draw the shape at its first
        AND A                    ; position, CLEAR the carry flag
        RET                      ; before returning to signal - MOVE
                                 ; UNSUCCESSFUL
DRAW_BLOB:
        PUSH DE                  ; save DE
        CALL PLOT_ADDR           ; calculate the screen address at
                                 ; which to draw the shape (from DE)
        LD DE,SHAPE              ; make DE point to the shape data
        EX AF,AF'                ; clear the alternative carry flag
        AND A
        EX AF,AF'
        LD B,8                   ; there are 8 pixel rows in the shape
BLOB10: PUSH BC                  ; save the counter
        PUSH DE                  ; ... and the shape pointer
        LD B,C                   ; B = C = X pixel position (1 - 8)
        LD A,(DE)                ; get the shape data byte
        LD D,A                   ; put it in DE (E = 0)
        LD E,0
BLOB20: SRL D                    ; rotate DE as required to bring the
                                 ; shape data into the correct place
        DJNZ BLOB20              ; for outputting to the screen
                                 ; The detection and output stage
        LD A,D                   ; get the leftmost byte of data and
        LD (HL)                  ; logically XOR it with the screen
        LD (HL),A                ; data then store it in the screen
        AND D                    ; mask off the bits we have just put
        CP D                     ; in and check to see that they are
                                 ; the same - Zero flag set
        JR Z,BLOB30              ; jump if the same - no collision
        EX AF,AF'                ; set the alternative carry flag to
        SCF                      ; indicate that a collision has in
        EX AF,AF'                ; fact occurred
BLOB30: INC HL                   ; step on the screen point across
        LD A,E                   ; the screen and now treat the right
        XOR (HL)                 ; most byte of shape data in the same
        LD (HL),A                ; way - XORing to the screen, masking
        AND E                    ; the bits we are interested in and
        CP E                     ; comparing to check that they are
        JR Z,BLOB40              ; the same - jumping if they are
        EX AF,AF'                ; as before, set the alternative
        SCF                      ; carry flag if a collision has
        EX AF,AF'                ; occurred
BLOB40: DEC HL                   ; step the screen pointer back to its
        INC H                    ; first place and increment it down
        LD A,H                   ; the screen
        AND 7                    ; if within the same character cell
        JR NZ,BLOB50             ; then jump
        LD A,L                   ; else add 32 to the low byte of the
        ADD A,£20                ; screen pointer
        LD L,A
        JR C,BLOB50              ; if transition across a screen
                                 ; 'third' has been made then jump
        LD A,H                   ; else subtract 8 off the pointer
        SUB 8                    ; high byte
        LD H,A
BLOB50: POP DE                   ; restore the shape pointer
        POP BC                   ; and the 8 pixel row counter
        INC DE                   ; increment the shape pointer
        DJNZ BLOB10              ; and decrement the counter
        EX AF,AF'                ; make the alternative carry flag
        POP DE                   ; available to the CALLing routine
        RET                      ; restore DE and return
PLOT:
        PUSH BC                  ; save registers from corruption
        PUSH DE
        CALL PLOT_ADDR           ; calculate the screen plot address
        OR (HL)                  ; and OR in the pixel to
        LD (HL),A                ; the screen
        POP DE
        POP BC                   ; restore registers and return
        RET
PLOT_ADDR:
        LD A,D                   ; check the Y coordinate range to see
        CP 192                   ; that it is not off the screen
        RET NC                   ; return if it is
        AND £C0                  ; put the screen 'third' bits into
        RRA                      ; bits 3 and 4 with a 010 in bit
        SCF                      ; positions 5, 6 and 7
        RRA
        RRA
        XOR D                    ; merge in the bits 0, 1, and 2 from
        AND £F8                  ; the Y coordinate
        XOR D
        LD H,A                   ; and store in H
        LD A,E                   ; move the top 5 bits of the X co-
        RLCA                     ; ordinate into bits 0, 1, 2 and 6, 7
        RLCA
        RLCA
        XOR D                    ; merge in bits 3, 4 and 5 from the
        AND £C7                  ; Y coordinate
        XOR D
        RLCA                     ; rotate the byte twice more and
        RLCA                     ; hey presto we have
        LD L,A                   ; the low byte of the screen address
        LD A,E                   ; get the three lower bits of the X
        AND 7                    ; coordinate and increment them to
        INC A                    ; give the range 1 - 8
        LD B,A                   ; copy it to B and C
        LD C,A
        LD A,1                   ; set bit 0 of A
PLOT10: RRCA                     ; rotate it so that the set bit is
        DJNZ PLOT10              ; in the correct place before
        RET                      ; returning
Y_RAND:
        CALL RAND_NUM            ; get an 8-bit random number and
        CP 192                   ; check to see that it is less than
        JR NC,Y_RAND_NUM         ; 192. Jump back if it isn't until
        RET                      ; we get a valid number less than 192
RAND_NUM:
        LD HL,(SEED_POINTER)     ; the random number is obtained by
        INC HL                   ; poking the Spectrum ROM from £0000
        LD A,H                   ; to £4000
        AND £3F                  ; the pointer to the ROM address is
        LD H,A                   ; incremented each time we call the
        LD (SEED_POINTER),HL     ; random number routine and the
        LD A,(HL)                ; accumulator is loaded with the
        RET                      ; current pointer value before
                                 ; returning

                                 ; this is the 8 bytes of shape data
SHAPE:          BYTE £FF,£81,£81,£9F,£80,£81,£81,£FF
                                ; the random number pointer
SEED_POINTER:
        WORD 2000

                                ; initial values for the 6 shape
                                ; variables
BLOB_VARS:
                WORD £3010,£FF01
                WORD £0950,£00FF
                WORD £0960,£0101
                WORD £9F70,£FF00
                WORD £9F80,£00FF
                WORD £7F10,£00FF
</pre>
