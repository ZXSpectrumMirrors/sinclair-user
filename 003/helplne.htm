<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Sinclair User 3 - Helpline</title>
<link rel="stylesheet" type="text/css" href="../shared/general.css">
<meta name="keywords" content="Sinclair, ZX80, ZX81, Spectrum, QL">
<meta name="description" content="Andrew Hewson's Helpline from Sinclair User, June 1982">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#660099">

<p align="center" class="first"><a href="mindgms.htm"><img src="../shared/images/lbutton.gif" width=15 height=19 border=0 alt="Mind Games"></a>
<a href="index.htm"><img src="../shared/images/hbutton.gif" width=15 height=19 border=0 alt="Issue 3 Contents"></a>
<a href="../004/index.htm"><img src="../shared/images/rbutton.gif" width=15 height=19 border=0 alt="Issue 4"></a></p>

<table border="1" cellpadding="10" align="right">
<tr><td><font size="+2"><b>helpline</b></font></td></tr>
</table>

<hr noshade>
<br clear=all>
<br>

<table width="220" border="0" cellpadding="10" align="right">
<tr align="center"><td><img src="../shared/images/hewson1.jpg" width=200 height=300 border=0 alt="">
<br>
<p class="first"><b><font size="-1">Andrew Hewson</font></b></p>
</td></tr>
</table>

<h1>Making the best use of memory</h1>

<p class="first"><b><font size="+1">In this column Andrew Hewson, author of <i>Hints &amp; Tips for the ZX-80</i> and <i>Hints &amp; Tips for the ZX-81</i>, answers your questions on hardware and software for Sinclair computers.</font></b></p>

<p class="first">THERE is a great deal of interest in the various ZX-81 RAM packs on the market and this month's column is devoted to questions about the efficient use of memory to enable you to decide which RAM would suit you best. I also answer some questions about the RAMS. Susan James writes:</p>

<p><b>I have a 1K ZX-81 and I keep running out of memory. Is there an easy way to work out how much space is required by a program? Have you any tips about how to shorten programs without altering their function?</b></p>

<p>The answer to the first question is no. The amount of space used to hold the program can be found by entering:</p>

<pre>PRINT PEEK 16396+256*PEEK 16397-16509</pre>

<p>That line calculates the address of the end of the program area - held in D FILE at 16396 and 16397 - and subtracts the address of the beginning of the program area - i.e., 16509 - but more space is required when the program is running and to hold the display file.</p>

<p>In the ZX-81, the display file occupies 25 bytes plus one byte for each character on the screen including leading blanks generated by PRINT AT, TAB and commas in PRINT statements. Space is also needed during execution to hold the variables area, the calculator stack and the machine and GO SUB stacks.</p>

<p>The amount of spare space at any time is the difference between the address held in the stack pointer (SP) and the address held in STKEND - at 16412. Unfortunately SP can be obtained only using a machine code routine.</p>

<p>In any case, the use of memory changes dynamically during execution and so the amount of spare space varies, too; hence my advice is that if you want to know how much space your program alone uses, then have a look at D FILE by entering:</p>

<pre>PRINT PEEK 16396+256*PRINT PEEK 16397</pre>

<p>The bigger your program, the bigger the result. Alternatively, for an idea of how much space has been used after a program has RUN, have a look at STKEND by entering:</p>

<pre>PRINT PEEK 16412+256*PRINT PEEK 16413</pre>

<img src="helplne1.gif" width=131 height=150 hspace=10 vspace=10 border=0 align="right" alt="8K-16K-48K RAM">

<p>The difference between the result and RAMTOP - 17408 on the 1K ZX-81, 32768 with the 16K RAM - reflects the amount of spare space but allows about 100 bytes for the stack.</p>

<p>There are many tricks you can use to shorten a program without changing its function and to use them to full effect you need to understand the code used to store Basic program lines. There are three rules: Each line has an overhead of five bytes - two bytes to hold the line number, followed by two bytes to hold the length of the remainder of the line and a single byte containing decimal 118 at the end of the line.</p>

<p>Each character - letters, punctuation marks, graphics characters occupies one byte each, as do keywords like PRINT, LET, FOR.</p>

<p>Numbers are held both in character form and in numeric form. The character form uses one byte per digit and is followed by a byte containing 126 and then five bytes containing the numeric form. I explained the interpretation of the numeric form in detail <a href="../002/helplne.htm">last month</a>.</p>

<p>For an idea of the way the rules work, plug in your ZX-81 and enter:</p>

<pre>10 FOR A=16509 TO 16548
20 PRINT CHR PEEK A
30 NEXT A.</pre>

<p>That program looks at the contents of the first 40 bytes of the program area, so it looks at itself.</p>

<p>My advice on shortening programs is:</p>

<p>Omit REM statements and keep PRINT statements as short as possible.</p>

<p>Use the code function to set variable values if possible; for example, use:</p>

<pre>LET A=CODE &quot;K&quot;</pre>

<p class="first">rather than</p>

<pre>LET A=48</pre>

<p>Keep the number of variables to a minimum by re-using them for a new purpose. Loop counters in particular use a good deal of space in the variables area.</p>

<p>Use single letters only for variable names.</p>

<p>The next question concerns the variables area and is from Ken Griffiths, who asks:</p>

<p><b>What is the formula for the size of an array?</b></p>

<p>The answer to the question is on page 173 of the ZX-81 Basic Programming manual. The formula is:</p>

<p>4 + 2*number of dimensions + 5*total number of elements.</p>

<p>An array B (2, 5, 6) has three dimensions and 2*5*6 = 60 elements. Hence it requires 4+2*3+5*60 = 310 bytes.</p>

<p>The equivalent formulae for the other variables are:</p>

<p><b>NUMBER</b>: 5 + one byte per character of the number</p>

<p><b>LOOP CONTROL VARIABLE</b>: 18 bytes</p>

<p><b>STRING</b>: 3 + one byte per string item</p>

<p><b>CHARACTER ARRAY</b>: 4+2*number of dimensions + number of elements.</p>

<p>I have received a number of questions about the RAMs, from, in particular, Jason Lowe, Steve Harrop, Geoff Hewitt, and Russell Walkinson, who, incidentally, wrote the funniest letter this month.</p>

<p><b>Can any program written for a ZX-81 with or without 16K RAM be used with any of the RAMS?</b> Yes, provided that you have sufficient RAM to accommodate the program it can be run using any of the RAMS but it is no use attempting to run a 16K program if you have, say, only a 4K RAM.</p>

<p><b>Are special programs required for RAMS larger than 16K?</b> No; you can add up to 48K of RAM starting at address 16384 without requiring special software, although there are two problems. The first is that the ZX-81 expects 16K of RAM at most and if you have more you must reset the RAMTOP pointer from the keyboard when you plug in the power supply. To do so, enter:</p>

<pre>POKE 16389,4*M+64-256*INT((4*M+64)/256) followed by NEW</pre>

<p class="first">where M is the amount of extra RAM you have. For example, if you add 32K of RAM enter:</p>

<pre>POKE 16389,192
NEW</pre>

<img src="helplne1.gif" width=131 height=150 hspace=10 vspace=10 border=0 align="right" alt="8K-16K-48K RAM">

<p>The second problem is that the display file must remain in the bottom 16K of RAM, as explained by Stephen Adam in Sinclair User, page 22, May 1982. Hence, unless you use special software, you are restricted to Basic programs smaller than about 15K. The remainder of the memory can be used to hold large arrays. The following line will give you an approximate idea of the size of your program:</p>

<pre>PRINT PEEK 16397/4-16;&quot;K&quot;.</pre>

<p><b>What is the point of adding RAM between 8K and 16K?</b></p>

<p>The Sinclair ROM uses addresses 0 to 8191; 8192 to 16383 is normally unused and the 1K internal RAM and 16K and other add-on RAM normally use 16384 and upwards. Some of the memories now available provide RAM between 8192 and 16383.</p>

<p>The advantage of the facility is that the area is not accessible to Sinclair Basic except by using PEEK and POKE commands. So it can be used to store data without the risk of it being over-written. In particular, it is not over-written when a program is LOADed from cassette and it can be used to pass data between programs in a similar way to the routines I described for saving data above RAMTOP in the <a href="../001/helplne.htm#ramtop">April 1982</a> <i>Sinclair User</i>.</p>

<p><b>What does paging mean?</b> The microprocessor on which the ZX-81 is based can look only at 64K of locations at any one time. Paging is a facility for separating RAM, usually but not necessarily into 64K blocks or &quot;pages&quot;, so that processors can switch from one &quot;page&quot; to another.</p>

<center><p>&copy; Copyright Hewson Consultants 1982</p></center>
<br clear=all>

<center><hr width="50%" noshade></center>

<p align="center" class="first"><a href="mindgms.htm"><img src="../shared/images/lbutton.gif" width=15 height=19 border=0 alt="Mind Games"></a>
<a href="index.htm"><img src="../shared/images/hbutton.gif" width=15 height=19 border=0 alt="Issue 3 Contents"></a>
<a href="../004/index.htm"><img src="../shared/images/rbutton.gif" width=15 height=19 border=0 alt="Issue 4"></a></p>

<h6 align="center">Sinclair User<br>June 1982</h6>

</body>
</html>

